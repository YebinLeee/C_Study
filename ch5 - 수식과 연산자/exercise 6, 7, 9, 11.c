#include <stdio.h>
int p2()
{
	// ch5 exercise 6번의 3 - 조건연산자. 논리 오류 있는가?
	int max, a, b, c;
	printf("a, b, c의 값을 순서대로 입력하시오: ");
	scanf_s("%d %d %d", &a, &b, &c);
	max  = a > b ? (a > c ? a : c) : b;
	printf("a > b ? (a > c ? a : c) : b = %d\n\n", max);
	
	/*
	printf("a, b의 값을 입력하시오: ");
	scanf_s("%d %d", &a, &b);
	 max = (a > b) ? (a:b);
	printf("(a > b) ? (a:b) = %d\n\n", max);
	*/ 
	// 위와 같이 괄호를 사용할 수 없다.

	// ch5 exercise 7번 : 단축계산 아님. 0이 아닌 수는 모두 참으로 간주한다.
	int i = -3, j = 2, k = 0, m;
	m = ++i && ++j && ++k;
	printf("i=%d\nj=%d\nk=%d\nm=%d\n\n", i, j, k, m);

	// 9번 - 비트 연산자 계산하기
	int x = 0x1111;
	printf("10진수 x = %d \n", x); // 16진수 표기 정수 0x1111은 10진수 숫자로는 4369 라는 숫자이다.
	printf("x & ~x: %x\n", x & ~x);
	// AND연산자: 두 비트가 둘다 1일때만 1 출력. x와 ~x는 비트가 서로 완전히 반대되는 것이기 때문에, 겹치는 비트가 없어 모두 0으로 출력.
	
	printf("x | ~x: %#x, %d \n", x | ~x, x|~x);
	// OR연산자: 두 비트 중 하나라도 1이 존재하면 1 출력. x와 ~x 둘 중 하나는 무조건 1을 가지고 있으므로, 연산 후 1로 출력.
	// 0001 0001 0001 0001 | 1110 1110 1110 1110 = 1111 1111 1111 1111

	printf("x ^ ~x: %#x, %d\n", x ^ ~x, x ^ ~x);
	// XOR연산자: 두 비트가 서로 다를 때 1출력. 서로 겹치는 것이 없기 때문에 연산 후 1로 출력:
	// 0001 0001 0001 00001 ^ 1110 1110 1110 1110 = 1111 1111 1111 1111

	printf("x ^ 0xffff: %#x \n\n", x ^ 0xffff);
	// XOR연산: 0001 0001 0001 00001 ^ 1111 1111 1111 1111 = 1110 1110 1110 1110 
	// 이는 10진수로 61166이라는 숫자이다.
	
	printf("%d %u\n", 0xffffffff, 0xffffffff);
	// 2의 보수를 이용하면 0xfffffffff는 -1이다. 반면, unsigned int 를 이용하면 40억대의 숫자가 나타난다.



	// 11번: 비트 이동연산자 계산하기
	printf("%x\n", 0x20 << 2);

	return 0;
}